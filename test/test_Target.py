import pytest
import pygame
from unittest.mock import MagicMock
from BackEnd.Target import Target

# Фікстура для ініціалізації pygame
@pytest.fixture(autouse=True)
def init_pygame():
    """Фікстура для ініціалізації та завершення роботи pygame для кожного тесту.
    Це гарантує, що pygame буде ініціалізований перед кожним тестом і коректно завершиться після нього.
    """
    pygame.init()  # Ініціалізуємо pygame
    yield  # Після завершення тесту викликається pygame.quit()
    pygame.quit()  # Завершуємо роботу pygame після тесту

# Тест для перевірки ініціалізації класу Target
def test_target_initialization():
    """Тест перевіряє ініціалізацію об'єкта Target.
    Перевіряється правильність ініціалізації атрибутів класу Target.
    """
    image = MagicMock()  # Мок для зображення, яке буде використовуватися для цілі
    target = Target(x=100, y=200, image=image, speed_multiplier=1.5)  # Створюємо екземпляр цілі

    # Перевірка, чи правильно ініціалізовані атрибути
    assert target.x == 100  # Перевіряємо, чи правильно встановлено x
    assert target.y == 200  # Перевіряємо, чи правильно встановлено y
    assert target.image == image  # Перевіряємо, чи зображення відповідає переданому мок-об'єкту
    assert target.speed_multiplier == 1.5  # Перевіряємо, чи правильно встановлений множник швидкості
    assert isinstance(target.rect, pygame.Rect)  # Перевірка, чи rect є об'єктом pygame.Rect

# Тест для перевірки руху цілі (метод move)
def test_target_move():
    """Тест перевіряє рух цілі за допомогою методу move.
    Перевіряємо, чи правильно змінюється позиція цілі після виклику методу move.
    """
    image = MagicMock()  # Мок для зображення
    target = Target(x=100, y=200, image=image, speed_multiplier=1)  # Створюємо ціль з початковими координатами

    # Збережемо початкове значення x для порівняння
    initial_x = target.x

    # Викликаємо метод move для оновлення позиції
    target.move(width=500)

    # Перевірка, чи змінилося значення x
    assert target.x == initial_x - 2  # Позиція повинна зменшитися на 2, оскільки ціль рухається ліворуч
    assert target.rect.x == target.x + 20  # Перевірка, чи змінився rect, і чи його x тепер відповідає новому положенню

# Тест для перевірки випадку, коли ціль виходить за межі екрана і з'являється з правої сторони
def test_target_move_off_screen():
    """Тест перевіряє, чи ціль з'являється з правої сторони після того, як виходить за межі екрану.
    Перевіряємо, чи правильно обробляється ситуація, коли ціль виходить за межі екрана і з'являється знову.
    """
    image = MagicMock()  # Мок для зображення
    target = Target(x=-200, y=200, image=image, speed_multiplier=1)  # Створюємо ціль, що починається поза екраном зліва

    # Викликаємо метод move, щоб перевірити, чи ціль повернеться з правої сторони
    target.move(width=500)

    # Перевірка, чи x знову встановлено на праву сторону екрана
    assert target.x == 500  # Позиція має бути рівною ширині екрану, щоб з'явитися з правого боку

# Тест для перевірки малювання цілі на екрані
def test_target_draw():
    """Тест перевіряє, чи правильно малюється ціль на екрані.
    Перевіряється, чи метод draw правильно викликає метод blit для відображення цілі.
    """
    image = MagicMock()  # Мок для зображення
    target = Target(x=100, y=200, image=image, speed_multiplier=1)  # Створюємо ціль з координатами (100, 200)

    screen = MagicMock()  # Мок для екрану

    # Викликаємо метод draw для малювання цілі
    target.draw(screen)

    # Перевірка, чи був викликаний метод blit з правильними аргументами
    screen.blit.assert_called_once_with(image, (100, 200))  # Перевіряємо, що метод blit був викликаний один раз з правильними координатами
    # Відповідні координати мають бути (100, 200), що відповідає позиції цілі на екрані


if __name__ == '__main__':
    pytest.main()
